# 9주차 Day03_ 트리

[TOC]

---



## 1. 트리

> 비선형 구조. 원소들 간 1:n 관계를 가지는 자료 구조

- 한 개 이상의 노드로 이루어진 유한 집합 

  - 최상위 노드 : `루트(root)` , 정점, 트리의 시작 노드
  - 나머지 노드: n개의 분리 집합 T1, T2, ...TN으로 분리될 수 있다.
  - 단말노드 : `잎(leaf) 노드`

  

- `노드`: 트리의 원소
- `간선(edge)` : 노드를 연결하는 선, 부모 노드와 자식 노드를 연결
- `형제 노드` : 같은 부모 노드의 자식 노드들
- `조상 노드` : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- `서브 트리(subtree)` : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- `자손 노드` : 서브 트리에 있는 하위 레벨의 노드들



- `차수(degree)` : 노드에 연결된 자식 노드의 수

  - 트리의 노드 : 트리에 있는 노드 차수 중 가장 큰 값
  - 단말 노드(리프 노드): 차수가 0인 노드, 자식이 없는 노드

- `높이` : 루트에서 노드에 이르는 간선의 수. 노드의 레벨

  - 트리의 높이 : 트리에 있는 노드 높이 중 가장 큰 값

  

- cf.  그래프는 N:N 이기에 트리는 그래프의 한 종류라 할 수 있다.





## 2. 이진트리

> 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리

-  각 노드가 자식 노드를 "최대한 2개"까지만 가질 수 있는 트리 : 왼쪽 자식 노드, 오른쪽 자식 노드

- 레벨 i에서의 노드의 최대 개수는 `2^i`
- 높이가 h인 이진 트리가 가질 수 있는 노드 : (h+1) ~ (2^h+1 - 1)개



### ⓐ 포화 이진 트리 (Full Binary Tree)

- 모든 레벨에 노드가 포화상태로 차 있는 이진 트리
- 높이가 h일 때, 최대 개수인 `(2^h+1 - 1)`의 노드를 가진 이진 트리
- 노드 번호: 1번(루트) ~ (2^h+1 - 1)번



### ⓑ 완전 이진 트리 (Complete Binary Tree)

> 높이가 h, 노드 수가 n일 때, 포화 이진 트리의 노드 번호 1번 ~ n번까지 빈 자리가 없는 이진 트리



### ⓒ 편향 이진 트리 (Skewed Binary Tree)

> 높이가 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리



### :exclamation: :heavy_exclamation_mark: 순회 (traversal) 

> 트리에 특화된 선회_ 트리의 각 노드를 중복되지 않게 전부 방문하는 것

- 트리는 비선형 구조이기 때문에 선후 연결 관계를 알 수 없다.
- 서브 트리 내에서만 순회하는 것도 가능하다.
- 3가지 기본적인 순회 방법 (이름이 부모노드 기준으로...)
  - 전위 순회 : VLR _ 부모노드 → 자식 노드를 좌, 우 순서로 
  - 중위 순회 : LVR _ 왼쪽 자식 노드 → 부모 노드 → 오른쪽 자식 노드
  - 후위 순회 : LRV _ 왼쪽 자식 노드 →  오른쪽 자식 노드 → 부모 노드 

#### 	⑴ 전위 순회

```python
# 부모 노드 : T
def preorder_traverse(T):
    if T:		# 존재하는 정점인지
        visit(T)
        preorder_traverse(T.left)
        preorder_traverse(T.right)
```

#### 	⑵ 중위 순회

```python
# 부모 노드 : T
def in_order(T):
    if T:		# 유효한 정점인지 (해당 노드가 있는지)
        in_order(ch1[v])
        visit(T)
        in_order(ch2[v])
```

#### 	⑶ 후위 순회

```python
# 부모 노드 : T
def post_order(T):
    if T:		# 유효한 정점인지 (해당 노드가 있는지)
        post_order(ch1[v])
        post_order(ch2[v])
        visit(T)
```

#### 	

#### 	

### 이진트리의 표현 - 배열

- 완전/포화이진트리의 경우

  - 1~N 번까지의 정점이 있으면 `(N+1)`개의 원소를 가진 배열을 만든다.
  - 정점 번호를 인덱스로 사용한다.
  - 번호가 i인 노드의 부모 노드 번호 : `i//2`
  - 번호가 i인 노드의 왼쪽 자식 노드 번호 : `2*i`
  - 번호가 i인 노드의 오른쪽 자식 노드 번호 : `2*i+1`
  - 레벨 n의 노드 번호 시작 번호는: `2^n` (레벨을 0부터 카운트함)
  - 레벨 i의 최대 노드 갯수 : `2^i`

  

- `정점 = 간선 - 1`

  - 간선의 수: 부모-자식 쌍의 수 

  - 정점번호 규칙: 
    - 포화이진트리인 경우: 부모<자식
    - 포화이진트리 아닌 경우:  1번이 루트라는 보장이 없음, 부모<자식이 아닐 가능성도 있음



### 이진트리의 저장

1. 부모 번호를 인덱스로 자식 번호를 저장

   ```python
   for i: 1 -> N
       read p,c
       if(c1[p] ==0)
          c1[p] = c
       else
   	   c2[p] = c
   ```

   - 문제를 풀 때, TREE에 정확한 규칙이 있는가 없는가

   ```PYTHON
   '''
   4
   1 2 1 3 3 4 3 5
   '''
   def pre_order(v):		# 전위순회
       if v:		# 0번 정점이 없으므로 0번은 자식이 없는 경우를 표시
           print(v)	# visit
           pre_order(ch1[v])
           pre_order(ch2[v])
   
   E = int(input())		# edge 수
   arr = list(map(int, input().split()))
   V = E +1 		# 정점 수 == 1번부터 V번까지 정점이 있을 때 마지막 정점
   # 마지막 정점 번호가 반드시 정점의 개수랑 같은 건 아니다. (0번부터 시작하는 경우)
   
   # 부모번호를 인덱스로 자식번호 저장
   ch1 = [0]*(V+1)
   ch2 = [0]*(V+1)
   for i in range(E):			# 부모-자식 E개의 쌍이 주어진 상태
       p, c = arr[i*2], arr[i*2+1]
       if ch1[p]==0:		# 아직 자식이 없는 경우
           ch1[p] = c
       else:
           ch2[p] = c
   # 여기까지 부모를 인덱스로 자식번호 저장
   
   pre_order(1)
   ```



2. 자식 번호를 인덱스로 부모번호 저장

   ```python
   # 자식 번호를 인덱스로 부모 번호 저장
   par = [0]*(V+1)
   for i in range(E):			# 부모-자식 E개의 쌍이 주어진 상태
       p, c = arr[i*2], arr[i*2+1]
       par[c] = p
   
   # root 찾기
   root = 0
   for i in range(1, V+1):
       if par[i]==0:
           root = i 
           break
   print(root)
       
   # 조상 찾기
   c = 5 			# 정점 c의 조상 찾기
   anc = []
   while par[c] != 0:		# 부모가 있다?
       anc.append(par[c])
       c = par[c]
   ```
   
   

### ⓓ 수식 트리

> 수식을 표현하는 이진 트리
>
> 연산자는 루트 노드이거나 가지 노드, 피연산자는 모두 잎 노드
>
> 기본적으로 후위순회 활용





## 3. 이진탐색 트리

> 탐색작업을 효율적으로 하기 위한 자료구조

- 모든 원소는 서로 다른 유일한 키를 갖는다.
- key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
- 왼쪽 서브트리와 오른쪽 서브트리도 이진탐색트리
- 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있다.



- **탐색 연산**

  - 키 값 x = 루트노드의 키 값 : 원하는 원소를 찾았으므로 탐색연산 성공
  - 키 값 x < 루트노드의 키 값 : 루트노드의 왼쪽 서브트리에 대해 탐색 연산 수행
  - 키 값 x >          "     "             :  "         "  의 오른쪽 서브트리에 대해 탐색 연산 수행

- **삽입 연산**

  - 같은 원소가 트리에 있으면 삽입할 수 없으므로 탐색하여 확인한다.
  - 먼저 탐색 연산을 수행 → 탐색 실패가 결정되는 위치가 삽입 위치가 된다.

- **삭제 연산**

  - 리프 노드인 경우 (차수가 0인 경우) : 그냥 지움 
  - 리프가 아니고 차수가 1인 경우: 탐색 - 삭제 - 후속처리(서브 트리 이동)
  - 리프 노드가 아닌 경우, 탐색 - 왼쪽 자식 노드 중 가장 큰 애 탐색 - 루트로 이동시킴

  

- 탐색 트리 - 성능

  - 탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸린다.
  - 평균의 경우(이진트리가 균형적으로 생성) : O(log n)
  - 최악의 경우(한쪽으로 치우친 경사 이진트리의 경우) : O(n)



## 4. 힙 (heap)

> 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조

- 부모가 항상 크거나, 부모가 항상 작거나 해야 함

- 최대 힙(max heap) : 가장 큰 키값을 가진 노드가 항상 루트에 위치
  - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
- 최소 힙(min heap)
  - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리



#### 힙 연산 

- 삽입
  - 조건: 완전 이진 트리 + 부모 > 자식
  - last += 1 하고 삽입

```python
# 최대 힙

def enq(n):
    global last
    last += 1			# 마지막 노드 추가
    tree[last] = n		# 완전 이진트리 유지
    c = last			# 새로 추가된 정점을 자식으로
    p = c//2			# 완전 이진트리에서의 부모 정점 번호
    while p>=1 and tree[p] < tree[c]:		# 부모가 있고, 자식 키 값이 더 크면 교환
        tree[p], tree[c] = tree[c], tree[p]
        c = p			# 좀 전의 부모를 자식으로 하고, 그 위에 더 있는지 확인하기
        p = c//2

# 포화 이진 트리의 정점번호 1 ~ 100
tree = [0]*(101)
last = 0			# 마지막 정점 번호
```

- 삭제
  - 루트 노드의 원소만을 삭제할 수 있다. : 루트에는 가장 큰 애가 들어가 있음
  - 완전 이진 트리를 유지
  - 루트의 원소 삭제 → last 값을 root로 보내고, last 마지막 노드를 삭제 → 자리 바꿔서 최대 힙 유지하기

```python
def deq():
    global last
    tmp = tree[1]				# 루트의 key값
    tree[1] = tree[last]		# 마지막 정점의 키를 루트로 복사
    last -= 1					# 마지막 정점 삭제
    
    # 부모 > 자식 규칙 유지
    p = 1
    c = p *2					# 왼쪽자식 노드 번호
    while c <= last: 			# 최대 힙 유지.. 왼쪽자식이 있으면
        if c+1 <= last and tree[c]<tree[c+1]:	# 오른쪽 자식노드도 있고 더 크면,
            c += 1				# 오른쪽 자식 선택
        if tree[p] < tree[c]:	# 자식 키 값이 더 크면 값 교환	
            tree[p], tree[c] = tree[c], tree[p]
            p = c
            c = p*2
        else:					# 자식이 없는 경우
            break
    return tmp					# 루트 값을 꺼낼 것
```



---

문제

```python
# 중위 순회
def in_order(T):
    if T<=N:
        in_order(T*2)
        print(tree[T], end='')
        in_order(T*2+1)

T = 10
for tc in range(1, T+1):
    N = int(input())
    tree = [0] * (N+1)
    for _ in range(N):
        a = list(input().split())
        tree[int(a[0])] = a[1]

    print(f'#{tc} ', end='')
    in_order(1)
    print()
```

