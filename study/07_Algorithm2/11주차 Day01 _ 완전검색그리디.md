# 11주차 Day01 _ 완전검색/그리디



## Baby-gin Game



## 순열 permutation

```python
nPr = n x (n-1) x.... x (n-r+1)
```



```python
def f(n,k):		# 순열 p[n]을 채우는 함수, k배열의 크기
    if n==k:
        print(p)
    else:
        for i in range(k):
            if used[i]==0:		# 앞에서 사용하지 않은 숫자인 경우
                used[i]=1		# 사용함으로 표시하고
                p[n] = a[i]		# p[n] 결정
                f(n+1,k)
                used[i]=0		# a[i]를 다른 위치에서 사용할 수 있도록 함
	return
                
a = [1,2,3]
p = [0]*3
used = [0]*3
f(0,3)
```



```python
def f(n,k,m):		# 순열 p[n]을 채우는 함수, k는 고를 개수, m은 주어진 숫자 개수
    if n==k:
        print(p)
    else:
        for i in range(m):
            if used[i]==0:		# 앞에서 사용하지 않은 숫자인 경우
                used[i]=1		# 사용함으로 표시하고
                p[n] = a[i]		# p[n] 결정
                f(n+1,k,m)
                used[i]=0		# a[i]를 다른 위치에서 사용할 수 있도록 함
	return
                
a = [1,2,3,4,5]
p = [0]*3
used = [0]*5
f(0,3,5)
```



## 부분집합

```python
for i1 in 0 -> 1
	bit[0] <- i1
    for i2 in 0 -> 1
    	bit[1] <- i2
        for i3 in 0 -> 1
        	bit[2] <- i3
            for i2 in 0 
            ....
```

#### 바이너리 카운팅을 통한 사전적 순서

- 원소의 갯수가 변해도 적용되기에 간편
- 원소 수에 해당하는 N개의 비트열을 이용한다
- n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다.



```python
arr = [3,6,7,1,5,4]
n = len(arr)

for i in range(0,(1<<n)):	# 1<<n 부분집합의 개수
    for j in range(0,n):		# 원소의 수만큼 비트를 비교함
        if i&(1<<j):			# i의 j번째 비트가 1이면 j번째 원소 출력
            print('%d'%arr[j], end='')
    print() 
```





## 조합

> 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

```python
nCr = n! / (n-r)!r! 	(n>=r)

nCr = n-1Cr-1 + n-1Cr		# 재귀적 표현
nC0 = 1
```



```python
for i: 0 -> 7	# j,k로 선택될 원소를 남김
    for j:
```







## 타키야끼 스터디 :taco:



```python
lst = [(6,14),(8,24),(8,16),(3,9)]
print(sorted(lst, key = lambda x : (x[0],-x[1])))
## [(3,9),(6,14),(8,24),(8,16)]

lst = [1, 2, 3, 4, 5, 6]
lst = lst(map(lambda x: 10*x, lst))
## [10, 20, 30, 40, 50, 60]
```

