# 객체지향 프로그래밍

> 프로그램을 여러 개의 독립된 객체들과 그 객체들 간의 상호작용으로 파악하는 프로그래밍 방법



- 객체(Object) : 속성(Attribute) + 기능(Method)
- 인스턴스(Instance) : 하나하나의 실체, 예
  - 속성: 객체들이 가지는 상태, 데이터
  - 메소드: 특정 객체에 적용 가능한 행위(함수)



- 절차지향 프로그래밍: global data 와 function의 연결

- 객체지향 프로그래밍 : 객체 안에 data와 기능(method)가 있고, 객체 간 상호작용이 가능해짐

  - 데이터와 기능 분리, 추상화된 구조(인터페이스)	


  - 데이터를 직접적으로 부각할 수 있는 형태
  - **장점 : 프로그램을 유연하고 변경이 용이하게 만든다 / 소프트웨어 개발과 보수를 간편하게 하고 / 직관적인 코드 분석이 가능하게 한다**



### 기본 문법

- 클래스(class) - 인스턴스(instance) - 속성(attribute) - 메소드(method)

  Person                  IU

- 클래스 정의 `class MyClass:`

- 인스터스 생성 `my_instance = MyClass()`

- 메소드 호출 `my_instance.my_method()`

- 속성 `my_instance.my_attribute`



### 인스턴스 변수

- 인스턴스 변수란? 인스턴스가 개인적으로 가지고 있는 속성(attribute)

  ```python
  생성자 메소드에서 self.name = name 으로 정의한 다음
  John.name 으로 할당
  ```

- 인스턴스 메소드? 인스턴스 변수를 사용하거나 인스턴스 변수에 값을 설정하는 메소드

- `self` 인스턴스 자기자신. 파이썬에서 인스턴스 메소드는 호출 시 첫번째 인자로 인스턴스 자신이 전달되게 설계
  - 매개변수 이름으로 self를 첫 번째 인자로 정의



- 생성자 메소드 : 인스턴스 변수들의 초기값을 설정 `__init__` 메소드 자동 호출

- 소멸자 메소드: 인스턴스 객체가 소멸되기 직전에 호출되는 메소드 `__del__`

- 매직 메소드: 

  - `__str__(self)` 해당 객체의 출력 형태를 지정. 프린트 함수를 호출할 때, 자동으로 호출됨

  - `__gt__(self)` : 부등호 연산자 (>, greater than)

    



### 클래스 변수

- 클래스 : 클래스 변수와 클래스 매서드
- 인스턴스 : 인스턴스 변수와 인스턴스 매서드



- 클래스 속성: 한 클래스의 모든 인스턴스가 똑같은 값을 가짐

  - 클래스 선언 내부에서 `pi = 3.14` 라고 정의

  

- 클래스 메소드

  - @classmethod  : 호출 시 첫번째 인자로 클래스(cls)가 전달된

    - cls 인자에만 접근할 수 있기 때문에 객체 인스턴스 상태를 수정할 수 없음

  - @staticmethod : 인스턴스 변수, 클래스 변수를 전혀 다루지 않는 메소드. 

    ​							단지 기능만을 하는 메소드를 정의할 때 사용

    ​							호출 시 어떠한 인자도 전달되지 않음

    - 클래스의 이름공간에 귀속 됨
    - 객체 상태, 클래스 상태 수정 X

  - @instancemethod : 클래스 자체에도 접근 가능

    - 인스턴스 메소드가 클래스 상태를 수정할 수도 있음
    - 클래스 자체에서는 인스턴스 메소드 호출할 수 없음



```python
- 인스턴스 메소드 : 호출한 인스턴스를 의미하는 `self 매개 변수`를 통해 인스턴스를 조작
- 클래스 메소드: 클래스를 의미하는 `cls 매개변수`를 통해 클래스를 조작
- 스태틱 메소드: 유틸리티적인 부분들. 주로 해당 클래스로 한정하는 용도로 사용
```



- 인스턴스와 클래스 간의 이름공간(namespace)

  - 인스턴스에서 특정 속성에 접근하면, 인스턴스- 클래스 순으로 탐색

    ```python
    class Person:
        name = "unknown"
        
        def talk(self):
            print(self.name)
            
    p1 = Person()
    p1.talk() #> 인스턴스 변수가 정의되어 있지 않아 클래스 변수 unknown 출력
    
    p2 = Person()
    p2.name = 'Kim'
    p2.talk() #> 인스턴스 변수 Kim 출력
    ```

    




# 객체 지향의 핵심 개념

> 추상화, 상속, 다형성, 캡슐화 "추상다캡"



### ⓐ 추상화

- ex. 사람 클래스 하에서 학생 클래스와 교수 클래스를 또 생성할 수 있음



### ⓑ 상속

> 두 클래스 사이 부모 -자식 관계를 정립

- `isinstance(object, classinfo)` : classinfo의 instance이거나 subclass인 경우 True

  ```python
  Class Student(Person):
  s1 = student()
  isinstance(s1, Person) True
  ```

- `issubclass(class, classinfo)`

  ```python
  issubclass(bool, int) #True: bool은 0,1 이고 int는 1,2,3
  issubclass(float, int) #False: 둘은 student와 professor의 관계라 볼 수 있음
  ```

- `super()` : 자식클래스에서 부모클래스를 사용하고 싶은 경우

  ```python
  class Student(Person):
      
      def __init__(self, name, age, student_id):
          super().__init__(name, age) #Person에서 정의한 것들 가져올 수 있음
          self.studnet.id = student_id
  ```

  

- 정리

  - 파이썬의 모든 클래스는 object로부터 상속됨
  - 부모 클래스의 모든 요소(속성, 메소드, 관계, 제약 조건)가 상속됨
  - super()를 통해 부모 클래스의 요소를 호출할 수 있음
  - 메소드 오버라이딩을 통해 자식 클래스에서 재정의 가능함
  - 상속관계에서의 이름 공간은 인스턴스, 자식 클래스, 부모 클래스 순으로 탐색



- 다중 상속 : 두 개 이상의 클래스를 상속받는 경우_ 먼저 쓰인 클래스꺼를 우선적으로



`mro메소드 (method resolution order)` 

- 해당 인스턴스의 클래스가 어떤 부모 클래스를 가지는지 확인하는 메소드
- 순서는 기본적으로 먼저 상속받은 것부터
- 인스턴스 → 자식 클래스 → 부모 클래스로 확장



### ⓒ 다형성(Polymorphism)

> 동일한 메소드가 클래스에 따라 다르게 행동할 수 있음. 동일한 메시지에 대해 다른 방식으로 응답할 수 있음

- **`메소드 오버라이딩`**: 상속받은 메소드를 재정의. 상속받은 클래스에서 같은 이름의 메소드로 덮어쓰기



### ⓓ 캡슐화

> 객체의 일부 구현 내용에 대한 외부로부터 직접적인 엑세스를 차단

- Pubic Access Modifier  :  언더바 없이 시작하는 메소드나 속성 _ 어디서나 호출이 가능. 일반적
- Protected A M (상속관계)  : 언더바 1개_ 부모 클래스 내부와 자식클래스에서만 호출 가능
- Private A M (본인) : 언더바 2개_ 본 클래스 내부에서만 사용이 가능 / 하위클래스 상속이나 호출이 불가능, 외부 호출이 불가능



#### getter 메소드 와 setter 메소드

- getter 메소드 : 변수의 값을 읽는 메소드
  - @property 데코레이터 사용
- setter 메소드 : 변수의 값을 설정하는 성격의 메소드
  - @변수.setter 사용





- from 모듈 import 함수/클래스/변수 as 이름 : 변수, 함수, 클래스를 가져오면서 그 이름을 지정