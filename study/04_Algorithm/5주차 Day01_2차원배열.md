# 5주차 Day01_ 2차원 배열



## 2차원 배열의 접근

> 1차원 list를 묶어놓은 list

- `A[1][2]` : 행, 열 순서

- `arr = [0, 1, 2, 3],[4, 5, 6, 7]`  (2행 4열의 2차원 리스트)

```python
# 숫자가 떨어져서 입력되면
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
# list ~ for 전까지는 1차원 list
# >> [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# 숫자가 붙어서 입력되면
N = int(input())
arr = [list(map(int, input())) for _ in range(N)]
```



- 배열 순회 : 각 원소에 접근하기.

- 행 우선 순회 : ☆저장할 때는 `0번부터` _ 행렬로 표현해서 읽을 때랑 헷갈리지 말기 (1부터 말하기도)

  ```python
  # n x m 배열의 모든 원소를 빠짐없이 조사하기
  # i 행의 좌표 # j 열의 좌표
  for i in range(n):
      for j in range(m): # 각 행의 모든 열 j
          Array[i][j] 
  ```

  ```python
  arr = [[0]*3]*4 (x)
  ```

  

- 열 우선 순회

  ```python
  # i 행의 좌표 # j 열의 좌표
  for j in range(m):
      for i in range(n):
          Array[i][j]
          
  for i in range(m):
      for j in range(n):
          Array[j][i]   
  ```

  

- 지그재그 순회

  ```python
  for i in range(n):
      if i%2 == 0:
          #for j: 0 → m-1 
      else:
          #for j: m-1 → 0 (반대로)
      
  for i in range(n):
      for j in range(m): #j는 증가하는 방향
          Array[i][j + (m-1-2*j)*(i%2)] #[i][m-1-j]
  ```

  

  ```python
  N = int(input())
  arr2 = [[0]*(N+1)] + [[0]+list(map(int, input().split())) for _ in range(N)]
  arr3 = [[0]*(N+2)] + [[0]+list(map(int, input().split()))+[0] for _ in range(N)] + [[0]*(N+2)] #0으로 완전히 둘러싼 배열
  ```

  

- 델타를 이용한 2차 배열 탐색

  - 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법

  ```PYTHON
  arr[0...N-1][0...N-1] # NxN 배열
  di ← [0, 0, -1, 1] 
  dj ← [-1, 1, 0, 0] #좌우상하
  
  dj ← [0, 0, -1, 1] 
  di ← [-1, 1, 0, 0] #상하좌우
  
  for k in range(4):
      ni = i + di[k]
      nj = j + dj[k]
      if 0<=ni<N and 0<=nj<M: #유효인덱스 ex. 배열에서 [0][0]인 부분은 걸러내야 함
          arr[ni][nj]
  ```

  - *(tip) 헷갈리면 그림 그려놓고 코드 짜기*

  ```python
  for di, dji in [(0,1), (1,0), (0,-1), (-1,0)]:
      ni = i + di
      nj = j + dj
      if 0 <=ni<N and 0<=nj<M:
          arr[ni][nj]
  ```

  ```python
  arr = [[1,2,3],[4,5,6],[7,8,9]]
  N = 3
  for i in range(N):
      for j in range(N):
          for di, dj in [(-1,0),(1,0),(0,-1),(0,1)]: #상하좌우
              ni = i + di
              nj = j + dj
              if 0 <=ni<N and 0<=nj<M:
                  print(i, j, arr[ni][nj])
              print()
              
  #>> 출력의 일부분
  # 1 1 2
  # 1 1 8
  # 1 1 4
  # 1 1 6
  ```

  - *(tip) 오른쪽부터 시계방향으로 돌아가는 순서 : 연산을 이용해서 접근할 때 더 편하다*

  

  **<연습문제>**

  ```python
  T = int(input())
  for tc in range(1, T+1):
      N = int(input())
      arr = [list(map(int, input().split())) for _ in range(N)]
  
      answer = 0
      for i in range(N):
          for j in range(N):
              for di, dj in [[0,1],[1,0],[0,-1],[-1,0]]:
                  ni, nj = i+di, j+dj
                  if 0 <= ni < N and 0 <= nj < N:
                      answer += abs(arr[i][j] - arr[ni][nj])
  
      print(f'#{tc} {answer}')
  ```

  - index 범위 설정해줄 때, `0<=ni<N` N보다 작아야한다!

  ```python
      answer = 0
      for i in range(N):
          for j in range(N):
              di = [0, 1, 0, -1]
              dj = [1, 0, -1, 0]
  
              for k in range(4):
                  ni, nj = i+di[k], j+dj[k]
                  if 0<=ni<N and 0<=nj<N:
                      answer += abs(arr[ni][nj]-arr[i][j])
  ```

  <img src="5%EC%A3%BC%EC%B0%A8%20Day01_2%EC%B0%A8%EC%9B%90%EB%B0%B0%EC%97%B4.assets/KakaoTalk_20220214_133440702.jpg" alt="참고" style="zoom:50%;" />



- 전치 행렬

