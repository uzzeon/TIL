- 여기에 있는 코드 모두 교재에 있는 거 그대로 가져온거임@@



##### @@ 정렬 : 버블 vs 카운팅 vs 선택

- 시간복잡도 정도는 알아두라는 식으로 언급했음!

| 알고리즘    | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법  | 비고                                                         |
| ----------- | ------------- | ------------- | -------------- | ------------------------------------------------------------ |
| 버블 정렬   | O(n^2)        | O(n^2)        | 비교와 교환    | 코딩이 가장 쉽다                                             |
| 카운팅 정렬 | O(n+k)        | O(n+k)        | 비교환 방식(?) | n이 비교적 작을 때만 가능하다<br /><u>별도의 저장공간</u>을 만들어서 주어진 문제를 해결한다. <br /><u>개수 정렬이 가장 빠르다.</u> |
| 선택 정렬   | O(n^2)        | O(n^2)        | 비교와 교환    | 교환의 회수가 버블, 삽입 정렬보다 작다.                      |



 - 선택정렬: 정렬하려는 구간의 맨 앞은 하나씩 이동을 하고(계속 바뀜), 구간의 맨 끝은 동일(n-1)
   - vs. 거품정렬: 구간의 끝이 점점 앞으로 감

---

##### @@ 검색 : 순차검색 vs 이진검색

- 순차 검색은 자료가 정렬된 경우, 정렬되지 않은 경우 모두 사용 가능

  이진 검색은 자료가 정렬된 경우에만 사용 가능

- 이진 검색은 검색 범위를 반으로 줄여가며 보다 빠르게 검색을 수행

---







# 1. 버블 정렬 vs 카운팅 정렬 vs 선택정렬 :star::star:

> 정렬: 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순;ascending) 혹은 그 반대 순서로 (내림차순; descending) 재배열하는 것



### (1) 버블 정렬 (Bubble Sort)

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 정렬 과정
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 정렬 : 원소는 앞에서 뒤로 이동하면서 정렬됨
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다 (오름차순)

```python
def BubbleSort(a, N):
    for i in range(N-1, 0, -1): #오름차순, 정렬구간
        for j in range(i): #비교할 원소 중 왼쪽 원소
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
    return
```



### (2) 카운팅 정렬 (Counting Sort)

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

- 단계 : 개수 세기 → 누적하기 → 그 결과를 이용해서 TEMP에 마지막으로 배치

  - (개수 세기) Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts 에 저장한다. ex. counts[0] 에는 0의 발생 회수가 저장됨. 숫자 '0' 이 4개 있으면 counts의 인덱스 0에는 4가 저장됨

  - (누적하기) 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다. 

  - (그 결과를 이용해서 TEMP에 마지막으로 배치) 주어진 DATA와 같은 크기의 TEMP: DATA 거꾸로 올라가면서,,


```python
def Counting_Sort(A, B, k)
# A [] 입력 배열 DATA
# B [] 정렬된 배열 TEMP
# C [] 카운트 배열 COUNTS

 C = [0] * (k+1)
    
    for i in range(0, len(A)):
        C[A[i]] += 1 # 각 숫자별 갯수를 나타내는 통 만들기
        
    for i in range(1, len(C)):
        C[i] += C[i-1] # 누적하기
        
    for i in range(len(B)-1, -1, -1): #거꾸로 가면서,,
        C[A[i]] -= 1
        B[C[A[i]]] = A[i]
```



### (3) 선택 정렬 ★★ : 그림으로도 설명 가능해야 하고, 코드로도 구현할 수 있어야 한다.

> 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식

- 과정

  - 주어진 리스트 중에서 최소값을 찾는다.

  - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.

  - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.


```python
# 오름차순 선택정렬
for i in range(N-2): #구간의 시작
    minIdx = i #구간의 시작을 최소값의 위치로 가정
    for j in range(i+1, N): #현재 구간에서 나머지 원소와 비교
        if arr[minIdx] > arr[j]:
            minIdx = j
    arr[i], arr[minIdx] = arr[minIdx], arr[i] #구간의 최소값을 구간 맨 앞으로 가져옴
```





# 2. 배열 순회 

> 행 우선 순회 vs 열 우선 순회 vs 지그재그 순회 vs 델타 이용한 2차 배열 탐색 vs 전치행렬

- 말로 비교할 거는 없는 거같고,,, 각각 코드 짤 줄 알아야... 그냥 코드 문제로 나올듯 (뇌피셜)





# 3. 검색: 순차검색 vs 이진검색 :star:

#### ⓐ 순차 검색(Sequential Search)

- 정렬되어있지 않은 경우

  - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾고,

    찾으면 그 원소의 인덱스를 반환하고 못찾으면 검색 실패

  - p.24 ]  ''배열의 값''과 ''배열의 인덱스''을 모두 확인해야 함// 이때, 배열의 값을 항상 먼저 확인해야 함 . if not 'IndexError'

- 정렬되어 있는 경우 (p.28)

  - 오름차순인 경우, 자료를 순차적으로 검색하면서 키 값을 비교하여 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색하지 않고 검색을 종료함.



#### ⓑ 이진 검색(Binary Search)

> 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행

- 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 **<u>검색 범위를 반으로 줄여가며 보다 빠르게 검색을 수행함</u>**
- **<u>반드시 자료가 정렬된 상태여야 한다.</u>**
- 코드 짤때, 그림그리면서 해보기. start랑 end 헷갈리지 말기
- 재귀함수도 가능한데 시간이 더 오래 걸림. 반복함수 기억하기

```python
def binarySearch(a, N, key)
	start = 0
    end = N-1
    while start <= end:
        middel = (start + end)//2
        if a[middle] == key:
            return true
        elif a[middle] > key:
            end = a[middle] - 1
        else:
            end = a[middle] + 1
    return fasle #검색 실패
```





# ? 찌끄레기들..   :bug:

1. 완전 검색: 모든 경우의 수를 나열해보고 확인하는 기법 (= Brute-force)

   수행속도는 느리지만 해답을 찾아내지 못할 확률이 작다.

2. 탐욕 알고리즘 개념 : 최적해를 구하는데 사용되는 근시안적 방법... 

   각 시점에서는 최적의 선택을 했지만 그것들을 수집해서 최종 해답을 만들었을 때 그것이 최적이라는 보장은 없다.

3. 부분집합 : 수업때 설명은 했지만 엄청 강조하지는 않은 느낌.. 일단 코드는 못짜더라도 이해는 해라~는 느낌..이것도 뇌피셜^^

```python
## 부분집합 출력하기
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)

for i in range(1<<n): # 부분 집합의 개수
    for j in range(n): #각각의 숫자에 대해 n개의 비트를 읽어본다
        if i & (1<<j): #i의 각 비트가 1인지 0인지 검사.. 
            		   # 0이 아니면 걔가 나타내는 숫자를 부분집합에 포함
            print(arr[j], end=", ") #j번 원소 출력
    print()
print() 
```



4. 비트 연산자

   - 8Bit = 1 Byte (메모리에 접근하는 최소 단위)

   - `&` : and	`|` : or	

   - `<<` : 피연산자의 비트 열을 왼쪽으로 이동시킨다. 제일 오른쪽 칸에는 0이 채워짐

   - `>>` : 피연산자의 비트 열을 오른쪽으로 이동시킨다. 제일 오른쪽 칸에 있던 애는 out됨

   - 기본적으로 같은 비트끼리, 비트단위로 연산한다. 

   - `1 << n` : 2^n. 즉 원소가 n개일 경우의 모든 부분집합의 수

     - ex. a =1 ,  a << 5   ▷  a=10000 

       `a = 1<<5` : 5번비트가 1인 값 = 5번비트만 1인 값 = 2^5
   
   - `i & (1<<j)` : i의 j번재 비트가 1인지 아닌지를 검사한다.
   
        - 비트가 1이면 연산의 결과가 0이 아닌 값, 비트가 0이면 연산의 결과가 0 값이 나온다.



5. **셀렉션 알고리즘**: 저장되어 있는 자료로부터 k번째로 큰/작은 원소를 찾는 방법

   - k번째로 작은 원소를 찾으려면 (0, k) 구간까지 정렬하기 → 필요한 위치까지만 정렬해서 답 찾기

   



# CF.

- 코드 짤 때 알아두면 좋을 애들...

  ```python
  print(*arr) #언팩킹 연산자
  ```

  ```python
  arr = list(map(int, input().split())) #2차원 배열 입력하기
  ```

  ```python
  for x in arr:
      print(x, end='') # 한 줄 출력하기
  print()
  ```

  
