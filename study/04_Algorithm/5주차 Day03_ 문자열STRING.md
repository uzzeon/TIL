# 5주차 Day01_ 2차원 배열



## 1. 문자열

> 123

- 각 문자에 대해서 대응되는 숫자를 정해 놓고 이것을 메모리에 저장하는 방법이 사용될 것
- 영어가 대소문자 합쳐서 52이므로 6비트(64가지)면 모두 표현할 수 있다. = **코드체계**
- 다국어 처리를 위해 표준을 마련 = **유니코드**
- 유니코드 인코딩 (UTF) 
  - UTF-8 (in web) : 기본적으로 4바이트인데 가변 // UTF-16 (in windows, java) // UTF-32 (in unix)



```python
s1 = list(input()) # 123 입력시 ['1', '2', '3'] 출력
s2 = input() #123 입력시 123 출력

s1[0] = 'd' #수정이 가능함. 원소가 바뀌어 들어감
s2[0] = 'd' #수정 안됨. Error 발생

a = ['a', 'b', 'c', '\0']

print('a', end='')
print('\n', end='')
print('b')
## 출력
# a
# b
```

```python
def mystrlen(s):
    i = 0
    while s[i]!='\0':
        i += 1
    return
a = ['a', 'b', 'c', '\0']
print(mystrlen(a)) #3
```

- `null '\0'`: 코드 & `none` 정의되지 않았다.



- 문자열 기호
  - '(홑따옴표), "(쌍따옴표), '''(홑 3개), """(쌍 3개)
  - `+`문자열 연결 (이어붙여주는 역할)  `*` 반복 역할 
- 문자열은 시퀀스 자료형으로 분류되고 , 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산 사용 가능
- 메소드: `replace(), split(), find(), isalpha()`
- 튜플과 같이 요소값을 변경할 수 없음 (immutable)



#### 문자열 뒤집기

- ⓐ 자기 문자열에서 뒤집는 방법이 있고, ⓑ 새로운 빈 문자열을 만들어 소스의 뒤에서부터 읽어서 타겟에 쓰는 방법이 있겠다.
- 자기 문자열을 이용할 경우에는 swap을 위한 임시 변수가 필요하며 반복 수행을 문자열 길이의 반만을 수행해야 한다.
  - 문자열 길이 9 -> 9/2.. 4회 반복

- `s.reverse()` , `s[::-1]` cf. reverse()는 list에서만 구현되지 string에서는 구현 안된다.
- `s1 == s2` 내용이 같다 `s1 is s2` 참조가 같다.
-  `<` `>` 소문자 문자열끼리 비교시 ''빠르니 느리니''를 물어보는 것 / 소문자 대문자끼리 비교하면 대문자가 더 크다고 나온다.
  - 텍스트랑 패턴이 정해져 있는 문제는 괜찮은데 그런 구분이 없는 경우 주의
  - 어떤 한 문자열이 다른 문자열 안에 들어가있는지 찾아봐라 => 누가 패턴이고 누가 텍스트인건지 찾는 과정을 한 번 거쳐야 함. 

​			Q. 한 문자열이 다른 문자열 안에 들어가 있는지 확인하시오	

```python
'''
abc . abcd
ba . abcd
cd . defg
'''
비교하는 두 문자열 중 누가 더 짧은지를 보고 순서를 정해야 한다.
```



#### 문자열 숫자를 정수로 변환하기 : int(s) 함수를 직접 만들어보기

```python
s = '123'
a = atoi(s)
print(a+1)

#문자열 숫자를 앞에서부터 가지고 오기
def atoi(s):
    i = 0
    for x in s:
        i = i*10 + ord(x) - ord('0') # ord('0') = 48, ord('1') = 49
    return i
# 처음 x = 1 → i = 1 ▷ x = 2 → i = 12 ▷ x = 3 → i = 123
```



```python
def itoa(a):
    s = ''
    while a>0:
        s = s + chr(ord('0') + a%10) #ord('0') = 48
        a //= 10
        return s[::-1]
a = 153
s = itoa(a)
print(s)
```



#### 회문 판별하기 - 인덱스 연산을 활용해서 반만 비교하기

```python
s = input()
N = len(s)

## 방법 1 ##
i = 0
while i<N//2:
    if s[i] != s[N-1-i]:
        break
    i += 1
if i == N//2:
    print('회문')
else:
    print('회문아님')
    
## 방법 2 ##
ans = '회문아님'
for i in range(N//2):
    if s[i] != s[N-1-i]:
        break
else:
    ans = '회문'
print(ans)    
```



#### join 매서드

```python
s = list(input())
s.reverse()
a = '-'.join(s)
print(a) #>> abc 입력시 c-b-a 출력
```



## 2. 패턴 매칭

> 고지식한 패턴 검색 알고리즘 / 카프-라빈 알고리즘 / KMP 알고리즘 / 보이어-무어 알고리즘



### ⑴ 고지식한 패턴 검색 알고리즘 (Brute Force) ★

> 본문 문자열을 처음~ 끝까지 순회하면서 패턴 내 문자들을 일일이 비교하는 방식



- 비교 시작 위치를 i라고 하면, i는 패턴의 길이를 고려한 위치까지 작동해야 한다. 범위!
- 실패시, i는 아까 시작한 위치에서 한 칸 다음 위치로 이동하고, j는 처음으로 돌아감



```python
t = 'TTTTAACTT' #전체 텍스트
p = 'TTA' #찾을 패턴 #패턴이 더 짧은 경우에 한정
N = len(t)
M = len(p)
ans = -1
for i in range(N-m+1): #비교 시작 인덱스
    for j in range(M):
        if t[i+j] != p[j]:
            break #불일치하는 경우 j for문을 빠져나와서 i를 하나 더 키워서 다시 반복해봄
    else:
        ans = i
        break
print(ans) #2 2번인덱스에서부터 p가 나온다.
        
    
for i in range(N-M+1):
    j = 0
    while j < M:
        if t[i+j] != p[j]:
            break
        j += 1
    if j ==M : #패턴을 찾음
        ans =i
        break
```



```python
def BruteForce(p,t):
    i = o # t의 인덱스
    j = 0 # p의 인덱스
    while j < M and i < N:
        if t[i] != p[j]:
            i = i-j #불일치시 i는 이전 시작위치로 되돌리고 i+1하니깐 ▶ i는 아까 시작점보다 하나 다음으로
            j = -1 #불일치시 j는 -1로 되돌리고, 그 다음 j+1되니까 0이 됨 ▶ 맨 앞으로 돌린다.
        i = i +1 #★★ if문 일치 불일치와 상관없이 계속 반복된다
        j = j+1
    if j == M : 
        retrun i - M # 검색 성공
    else: 
        return -1 # 검색 실패. i = N 다돌았는데 못찾음
```



### ⑵ KMP 알고리즘

> 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞부분에 대하여 다시 비교하지 않고 매칭을 수행

- 패턴을 전처리하여 배열 next[M]을 구하여 잘못된 시작을 최소화함

  `next[M]` : 불일치가 발생했을 경우 이동할 다음 위치



- 아이디어

  - i는 그냥 두고, j를 바꾼다. `j = next[j]` 
  - 일치하면 `i +=1 , j +=1`  
  - BUT 패턴 맨 앞에서 불일치하는 경우` i +=1, j = =1, j+=1`
  - 패턴 중간에 불일치하는 경우 `i는 그대로, j = next[j]` (현재 불일치가 나타난 인덱스..에 해당하는 table 값으로 바꿈)

  

- 방법 (p. 40)

  - 자기 자신에 대해서 고지식한 방법과 비슷하게 패턴을 찾음 + 새로운 테이블(Ta) 만들기
  - abcdabcef ... : 인덱스 1부터 비교 시작. b에서 불일치하면,  Ta에 자기 앞에 연속 일치한 애들의 갯수를 기록한다. 
    - Ta 맨 앞은 -1로 초기화해놓고 / b에서 불일치했을때 돌아갈 값. 앞에는 몇개가 일치하지?를 적는 칸.
  - 일치하다가 또 일치하지 않게 된다면 0으로 초기화함.

  ```python
  def kmp(t, p):
      N = len(t)
      M = len(p)
      lps = [0] * (M+1) #끝에 한 칸 더 만들어야 함 # 첫번째 칸을 -1을 두지 않고 lps =[0]*M으로 만들기도 함
      #preprocessing
      j = 0 # 일치한 개수이자 비교할 패턴 위치. 패턴 내에서 비교할 인덱스 
      lps[0] = -1
      for i in range(1, M):
          lps[i] = j
          if p[i] == p[j]:
              j += 1 #일치하면 i와 j가 둘다 1씩 증가함
          else:
              j = 0 # 불일치하면 j=0 = 처음 문자 인덱스
      lps[M] = j #테이블 마지막
      
  
      # 비교 #
      i = 0 #비교할 텍스트 위치
      j = 0 # 비교할 패턴 위치
      while i < N and j <= M: 
          if j ==-1 or t[i]==p[j]: #첫글자가 불일치하거나, 일치하면
              i += 1
              j += 1
          else: # 불일치하면
              j = lps[j]
          if j == M: #패턴을 찾은 경우
              print(i-M, end =' ') #패턴의 인덱스 출력
              j = lps[j] #패턴을 찾은 경우, 찾은 패턴을 제외하고 나머지에서 다시 비교 
      print()
      return
  
  
  t = 'zzzabcdabcdabcefabcd' 
  p = 'abcdabcef'
  kmp(t, p) #p 패턴이 나타나는 위치를 출력하고자 함
  ```

  

### ⑶ 보이어-무어 알고리즘

> 오른쪽에서 왼쪽으로 비교.
>
> 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼이 된다.

- 오른쪽 끝에 있는 문자가 불일치하고 그 문자가 패턴 내에 존재하는 경우, 해당 문자와 그 패턴 내 문자를 맞춰보고 다시 비교
- 패턴의 길이만큼 건너뛸 수 있다.



### (*) 문자열 매칭 알고리즘 비교

- 찾고자하는 문자열 패턴의 길이 m 총 문자열 길이 n
- 고지식한 : 수행시간 O(mn) ; 최악의 경우
- 카프-라빈: 수행시간 세타(n) ; 항상 이정도
- KMP: 수행시간 세타(n) ;



## 3. 문자열 암호화

- `시저 암호(Caesar cipher)` : 일정한 수만큼 평행이동하여 암호화
- `단일 치환 암호`: 문자변환표 활용. 각각 대칭되는 문자로 변환 => 복호화하기 위해서는 모든 키의 조합이 필요하다
- `bit열의 암호화` 배타적 논리합 연산 사용
- .....



### list 연습문제

##### code - user problem : <9386. 연속한 1의 개수>

```python
T = int(input())
for tc in range(1, T+1):
arr = list(map(int, input()))

cnt = 0
for i in arr:
    if arr[i] == 0:
        cnt = 0
    if arr[i] == 1:
        cnt += 1
        if maxV < cnt:
            maxV = cnt
```



 



## 4. 문자열 압축

> 1차원 list를 묶어놓은 list

- `A[1][2]` : 행, 열 순서



## 5. 문제풀이 연습

> 1차원 list를 묶어놓은 list

- `A[1][2]` : 행, 열 순서