# 6주차 Day03_



## DFS (깊이 우선 탐색)

> 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요함

- 두 가지 방법
  - 깊이 우선 탐색 (Depth First Search, DFS)
  - 너비 우선 탐색 (Breadth First Search, BFS)



#### 깊이 우선 탐색

> 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법

- 후입선출 구조의 스택 사용 

- ⓐ재귀 ⓑ반복함수

```python
## do while문

visited[], stack[] 초기화
DFS(s)
	v 방문; 
    visited[v] ← true;
    do {
        if (vd의 인접 정점 중 방문 안한 w찾기)
        	push(v);
            while(w) {
                w 방문;
                visited[w] ← true;
                push(w);
                v ← w;
                v의 인접 정점 중 방문 안한 w 찾기                
            }
        	v ← pop(stack);	#인접 정점 없으면
        } while(v)
end DFS()
```



## 계산기

> 문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산할 수 있다.

- 일반적 방법: ⓐ 중위표기법(연산자를 피연산자의 가운데 표기) A+B

  ​					  ⓑ 후위표기법(연산자를 피연산자 뒤에 표기하는 방법) AB+

  

#####  중위표기식의 후위표기식 변환

- 예) A*B - C/D

  1단계: ( (A*B)-(C/D) )

  2단계: ( (A B)* (C D)/ )-

  3단계: AB*CD/-

- ⓐ icp (in-coming priority) 밖에 있을 때	ⓑ isp (in-stack priority) 안에 있을 때
  	- 스택 top과 비교했을 때, 비어있거나 스택안의 우선순위보다 토큰의 우선순위가 더 높으면 push
  	- 닫는 괄호가 나오면, 연는 괄호가 나올 때까지 모두 pop() : 스택에서 pop했을 때 버리는게 아니라 수식에 붙인다.



#### 후위표기식 연산

: 스택 활용

- 연산자이면 스택에서 피연산자를 두 번 pop()하여 두 개 꺼낸다. 계산결과를 스택에 push
- 수식에서 더 이상 토큰이 없으면 스택에서 최종 결과값 pop()하여 출력



## 백트래킹 

> 해를 찾는 도중에 막히면 되돌아가서 다시 해를 찾아가는 기법

- 최적화 문제와 결정 문제를 해결할 수 있다.
  - 결정문제: 문제의 조건을 만족하는 해가 존재하는지의 여부를 yes 또는 no가 답하는 문제_ 미로찾기, n-Queen, Map coloring, 부분집합의 합 문제
  - 

- 백트래킹과 깊이우선탐색과의 차이

  - Prunning 가지치기: 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임
  - DFS는 모든 경로를 추적하는데 비해 깊이우선탐색은 불필요한 경로를 조기에 차단
  - 백트래킹 : 재귀에 깊이우선탐색 만들고 적당한 조건을 붙여서 가지치기 
  - 백트래킹은 모든 후보를 검사하지 않는다

  

  "백트래킹" 

  - 어떤 노드의 유망성을 점검한 후에 유망(promising) 하지 않다고 결정되면 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 감
  - 어떤 노드를 방문했을 때 그 노드를 포함한 경로 해답이 될 수 없으면 그 노드는 유망하지 않다고 하며 반대로 해답의 가능성이 있으면 유망하다고 한다.
  - 가지치기: 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않는다.

"상태 공간 트리"



#### 부분집합 구하기

- 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 powerset이라고 하며 구하고자 하는 어떤 집합의 원소 개수가 n일 경우, 부분집합의 개수는 2^n개이다. 



```python
def f(i, N):		#i 부분집합에 포함될지 결정할 원소의 인덱스, N은 전체 원소개수
    if i == N:		# 한 개의 부분집합 완성
        for j in range(N):
            if bit[j]:
                print(a[j], end=' ')
        print()
    
    else:
        bit[i] = 1
        f(i+1, N)
        bit[i] = 0
        f(i+1, N)
    return

a = [1,2,3]
bit = [0,0,0]
f(0,3)
```

'



재귀를 사용해서 부분집합을 생성할 수 있는가?

부분집합의 합을 구할 수 있는가?

가지치기를 추가할 수 있는가?

----



#### 부분집합의 합

```python
def f(i, N, s, t, rs)       # s 이전까지 고려된 원소의 합, t 목표값
    global cnt
    cnt += 1

    if s == t:              # 목표 값을 찾으면
        for j in range(N):
            if bit[j]:
                print(a[j], end=' ')
        print()
    elif i == N:            # 목표값을 못찾았는데 더 이상 고려할 원소가 없다
        return
    elif s > t:             # 고려한 원소의 합 s가 이미 목표를 초과한 경우
        return
    elif s + rs < t:
        return
    else:
        bit[i] = 1
        f(i+1, N, s+a[i], t, rs-a[i])
        bit[i] = 0
        f(i+1, N, s, t, rs-a[i])
    return

N = 10
a = [x for x in range(1, N+1)]
bit = [0]*N
cnt = 0
t = 10
f(0, N, 0, t, sum(a))
```

- 추가 고려 사항

  고려한 구간의 합: S (포함될 요소만 더한 값) / 남은 구간의 합: RS (요소 전부를 다 더한 값)

  S > T 이면 중단, S +RS < T 이면 중단

   

 #### 순열

- 앞에서 사용한 것은 뒤에 사용하지 못한다. (앞에서 사용한 것이 다음 번에 영향을 준다)
- i = 0 ... P에 1을 둠 



```python
def f(i, N):
    if i==N:
        print(p)
    else:
        for j in range(i, N):
            p[i], p[j] = p[j], p[i]
            f(i+1, N)
            p[i], p[j] = p[j], p[i]
            
p = [1,2,3] # [x for x in range(1, N+1)]
N = 3
f(0, N)
```



## 분할 정복 알고리즘

```python
C^n = C^(n/2) * C^(n/2)		# n은 짝수
	= C^(n-1/2) * C^(n-1/2)	* C			# n은 홀수
```



## 퀵 정렬

> 주어진 배열을 두 개로 분할하고 각각을 정렬한다.

- 기준 아이템(pivot item)을 중심으로 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.
- 합병정렬과 달리 각 부분 정렬 후 합병이라는 후처리 작업이 필요하지 않는다.

​		<u>L : 피봇보다 크거나 같은 원소를 만나면 멈추고, R: 피봇보다 작은 원소를 만나면 멈춰라</u>	

​		L과 R이 만나면 그 만난위치의 원소와 피봇을 교환하여 피봇 원소의 위치를 확정한다.

- 최악의 시간 복잡도 : `O(n^2)`로 합병정렬에 비해 좋지 못하다. but 평균적으로는 빠르다.
- 평균 복잡도: `nlogn`



## 인접행렬

